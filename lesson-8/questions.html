<h1 id="1">1</h1>
<pre><code class="lang-javascript">[[<span class="hljs-name">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-name">2</span>, <span class="hljs-number">3</span>]].reduce(
  (<span class="hljs-name">acc</span>, cur) =&gt; {
    return acc.concat(<span class="hljs-name">cur</span>)<span class="hljs-comment">;</span>
  },
  [<span class="hljs-name">1</span>, <span class="hljs-number">2</span>]
)<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li>A: <code>[0, 1, 2, 3, 1, 2]</code></li>
<li>B: <code>[6, 1, 2]</code></li>
<li>C: <code>[1, 2, 0, 1, 2, 3]</code></li>
<li>D: <code>[1, 2, 6]</code></li>
</ul>
<details><summary><b>Ответ</b></summary>
<p>

#### Ответ: C

<code>[1, 2]</code> - начальное значение, с которым инициализируется переменная <code>acc</code>. После первого прохода <code>acc</code> будет равно <code>[1,2]</code>, а <code>cur</code> будет <code>[0,1]</code>. После конкатенации результат будет <code>[1, 2, 0, 1]</code>.

Затем <code>acc</code> равно <code>[1, 2, 0, 1]</code>, а <code>cur</code> равно <code>[2, 3]</code>. После слияния получим <code>[1, 2, 0, 1, 2, 3]</code>.

</p>
</details>

<h1 id="2">2</h1>
<pre><code class="lang-javascript"><span class="hljs-attribute">const bird</span> = {
  size: <span class="hljs-string">"small"</span>
};

<span class="hljs-attribute">const mouse</span> = {
  name: <span class="hljs-string">"Mickey"</span>,
  small: true
};
</code></pre>
<ul>
<li>A: <code>mouse.bird.size</code></li>
<li>B: <code>mouse[bird.size]</code></li>
<li>C: <code>mouse[bird[&quot;size&quot;]]</code></li>
<li>D: Все варианты валидны</li>
</ul>
<details><summary><b>Ответ</b></summary>
<p>

#### Ответ: A

В JavaScript все ключи объекта являются строками (кроме Symbol). И хотя мы не <em>набираем</em> их как строки, они всегда преобразовываются к строкам под капотом.

JavaScript интерпретирует (или распаковывает) операторы. При использовании квадратных скобок JS замечает <code>[</code> и продолжает пока не встретит <code>]</code>. Только после этого он вычислит то, что находится внутри скобок.

<code>mouse[bird.size]</code>: Сперва определяется <code>bird.size</code>, которое равно <code>&quot;small&quot;</code>. <code>mouse[&quot;small&quot;]</code> возвращает <code>true</code>.

Но с записью через точку так не происходит. У <code>mouse</code> нет ключа <code>bird</code>. Таким образом, <code>mouse.bird</code> равно <code>undefined</code>. Затем мы запрашиваем ключ <code>size</code>, используя точечную нотацию: <code>mouse.bird.size</code>. Так как <code>mouse.bird</code> это <code>undefined</code>, мы запрашиваем <code>undefined.size</code>. Это не является валидным, и мы получаем ошибку типа <code>Cannot read property &quot;size&quot; of undefined</code>.

</p>
</details>

<h1 id="3">3</h1>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">firstName, lastName</span>) </span>{
  <span class="hljs-keyword">this</span>.firstName = firstName;
  <span class="hljs-keyword">this</span>.lastName = lastName;
}

<span class="hljs-keyword">const</span> member = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"Lydia"</span>, <span class="hljs-string">"Hallie"</span>);
Person.getFullName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.firstName}</span> <span class="hljs-subst">${<span class="hljs-keyword">this</span>.lastName}</span>`</span>;
}

<span class="hljs-built_in">console</span>.log(member.getFullName());
</code></pre>
<ul>
<li>A: <code>TypeError</code></li>
<li>B: <code>SyntaxError</code></li>
<li>C: <code>Lydia Hallie</code></li>
<li>D: <code>undefined</code> <code>undefined</code></li>
</ul>
<details><summary><b>Ответ</b></summary>
<p>

#### Ответ: A

Нельзя добавлять свойства конструктору, как обычному объекту. Если нужно добавить фичу всем объектам, то необходимо использовать прототипы. В данном случае

<code>js
Person.prototype.getFullName = function () {
  return `${this.firstName} ${this.lastName}`;
}</code>

сделает метод <code>member.getFullName()</code> рабочим. В чем тут преимущество? Предположим, что мы добавили этот метод к конструктору. Возможно, не каждому экземпляру <code>Person</code> нужен этот метод. Это приведет к большим потерям памяти, т.к. все экземпляры будут иметь это свойство. Напротив, если мы добавим этот метод только к прототипу, у нас будет только одно место в памяти, к которому смогут обращаться все экземпляры!

</p>
</details>

<h1 id="4">4</h1>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(name);
  <span class="hljs-built_in">console</span>.log(age);
  <span class="hljs-keyword">var</span> name = <span class="hljs-string">"Lydia"</span>;
  <span class="hljs-keyword">let</span> age = <span class="hljs-number">21</span>;
}

sayHi();
</code></pre>
<ul>
<li>A: <code>Lydia</code> и <code>undefined</code></li>
<li>B: <code>Lydia</code> и <code>ReferenceError</code></li>
<li>C: <code>ReferenceError</code> и <code>21</code></li>
<li>D: <code>undefined</code> и <code>ReferenceError</code></li>
</ul>
<details><summary><b>Ответ</b></summary>
<p>

#### Ответ: D

Внутри функции мы сперва определяем переменную <code>name</code> с помощью ключевого слова <code>var</code>. Это означает, что переменная будет поднята (область памяти под переменную будет выделена во время фазы создания) со значением <code>undefined</code> по умолчанию, до тех пора пока исполнение кода не дойдет до строчки, где определяется переменная. Мы еще не определили значение <code>name</code> когда пытаемся вывести её в консоль, поэтому в консоли будет <code>undefined</code>.

Переменные, определенные с помощью <code>let</code> (и <code>const</code>), также поднимаются, но в отличие от <code>var</code>, не <i>инициализируются</i>. Доступ к ним не возможен до тех пор, пока не выполнится строка их определения (инициализации). Это называется &quot;временная мертвая зона&quot;. Когда мы пытаемся обратиться к переменным до того момента как они определены, JavaScript выбрасывает исключение <code>ReferenceError</code>.

</p>
</details>

<h1 id="5">5</h1>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAge</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">  "use strict"</span>;
  age = <span class="hljs-number">21</span>;
  <span class="hljs-built_in">console</span>.log(age);
}

getAge();
</code></pre>
<ul>
<li>A: <code>21</code></li>
<li>B: <code>undefined</code></li>
<li>C: <code>ReferenceError</code></li>
<li>D: <code>TypeError</code></li>
</ul>
<details><summary><b>Ответ</b></summary>
<p>

#### Ответ: C

Используя <code>&quot;use strict&quot;</code>, можно быть уверенным, что мы по ошибке не побъявим глобальные переменные. Мы ранее нигде не объявляли переменную <code>age</code>, поэтому с использованием <code>&quot;use strict&quot;</code> возникнет <code>ReferenceError</code>. Без использования <code>&quot;use strict&quot;</code> ошибки не возникнет, а переменная <code>age</code> добавится в глобальный объект.

</p>
</details>

<h1 id="6">6</h1>
<pre><code class="lang-javascript">+true<span class="hljs-comment">;</span>
!<span class="hljs-string">"Lydia"</span><span class="hljs-comment">;</span>
</code></pre>
<ul>
<li>A: <code>1</code> и <code>false</code></li>
<li>B: <code>false</code> и <code>NaN</code></li>
<li>C: <code>false</code> и <code>false</code></li>
</ul>
<details><summary><b>Ответ</b></summary>
<p>

#### Ответ: A

Унарный плюс приводит операнд к числу. <code>true</code> это <code>1</code>, а <code>false</code> это <code>0</code>.

Строка <code>&#39;Lydia&#39;</code> это &quot;истинное&quot; значение. На самом деле мы спрашиваем &quot;является ли это истинное значение ложным&quot;? Ответ: <code>false</code>.

</p>
</details>

<h1 id="7">7</h1>
<pre><code class="lang-javascript"><span class="hljs-built_in">var</span> <span class="hljs-built_in">num</span> = <span class="hljs-number">8</span>;
<span class="hljs-built_in">var</span> <span class="hljs-built_in">num</span> = <span class="hljs-number">10</span>;

console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">num</span>);
</code></pre>
<ul>
<li>A: <code>8</code></li>
<li>B: <code>10</code></li>
<li>C: <code>SyntaxError</code></li>
<li>D: <code>ReferenceError</code></li>
</ul>
<details><summary><b>Ответ</b></summary>
<p>

#### Ответ: B

С помощью ключевого слова <code>var</code> можно определять сколько угодно переменных с одним и тем же именем. Переменная будет хранить последнее присвоенное значение.

Но такой трюк нельзя проделать с <code>let</code> и <code>const</code>, т.к. у них блочная область видимости.

</p>
</details>

<h1 id="8">8</h1>
<pre><code class="lang-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(a, b) {
  <span class="hljs-keyword">return</span> <span class="hljs-type">a</span> + b;
}

sum(<span class="hljs-number">1</span>, <span class="hljs-string">"2"</span>);
</code></pre>
<ul>
<li>A: <code>NaN</code></li>
<li>B: <code>TypeError</code></li>
<li>C: <code>&quot;12&quot;</code></li>
<li>D: <code>3</code></li>
</ul>
<details><summary><b>Ответ</b></summary>
<p>

#### Ответ: C

JavaScript это <strong>динамически типизированный язык</strong>: мы не определяем тип переменных. Переменные могут автоматически быть преобразованы из одного типа в другой без нашего участия, что называется <em>неявным приведением типов</em>. <strong>Приведение</strong> это преобразование из одного типа в другой.

В этом примере JavaScript сконвертировал число <code>1</code> в строку, чтобы операция внутри функции имела смысл и вернула значение. Во время сложения числа (<code>1</code>) и строки (<code>&#39;2&#39;</code>) число преобразовывается к строке. Мы можем конкатенировать строки вот так: <code>&quot;Hello&quot; + &quot;World&quot;</code>. Таким образом, <code>&quot;1&quot; + &quot;2&quot;</code> возвращает <code>&quot;12&quot;</code>.

</p>
</details>

<h1 id="9">9</h1>
<pre><code class="lang-javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">typeof</span> <span class="hljs-number">1</span>);
</code></pre>
<ul>
<li>A: <code>&quot;number&quot;</code></li>
<li>B: <code>&quot;string&quot;</code></li>
<li>C: <code>&quot;object&quot;</code></li>
<li>D: <code>&quot;undefined&quot;</code></li>
</ul>
<details><summary><b>Ответ</b></summary>
<p>

#### Ответ: B

<code>typeof 1</code> возвращает <code>&quot;number&quot;</code>.
<code>typeof &quot;number&quot;</code> возвращает <code>&quot;string&quot;</code>

</p>
</details>

<h1 id="10">10</h1>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">(</span>) =&gt;</span> <span class="hljs-number">0</span>)();
}

<span class="hljs-keyword">typeof</span> sayHi();
</code></pre>
<ul>
<li>A: <code>&quot;object&quot;</code></li>
<li>B: <code>&quot;number&quot;</code></li>
<li>C: <code>&quot;function&quot;</code></li>
<li>D: <code>&quot;undefined&quot;</code></li>
</ul>
<details><summary><b>Ответ</b></summary>
<p>

#### Ответ: B

Функция <code>sayHi</code> возвращает значение, возвращаемое из немедленно вызываемого функционального выражения (IIFE). Результатом является <code>0</code> типа <code>&quot;number&quot;</code>.

Для информации: в JS 8 встроенных типов: <code>null</code>, <code>undefined</code>, <code>boolean</code>, <code>number</code>, <code>string</code>, <code>object</code>, <code>symbol</code> и <code>bigint</code>. <code>&quot;function&quot;</code> не является отдельным типом, т.к. функции являются объектами типа <code>&quot;object&quot;</code>.
</p>
</details>

<h1 id="11">11</h1>
<pre><code class="lang-javascript">!!null;
!!<span class="hljs-string">""</span>;
!!<span class="hljs-number">1</span>;
</code></pre>
<ul>
<li>A: <code>false</code> <code>true</code> <code>false</code></li>
<li>B: <code>false</code> <code>false</code> <code>true</code></li>
<li>C: <code>false</code> <code>true</code> <code>true</code></li>
<li>D: <code>true</code> <code>true</code> <code>false</code></li>
</ul>
<details><summary><b>Ответ</b></summary>
<p>

#### Ответ: B

<code>null</code> - &quot;ложный&quot;. <code>!null</code> возвращает <code>true</code>. <code>!true</code> возвращает <code>false</code>.

<code>&quot;&quot;</code> - &quot;ложный&quot;. <code>!&quot;&quot;</code> возвращает <code>true</code>. <code>!true</code> возвращает <code>false</code>.

<code>1</code> - &quot;истинный&quot;. <code>!1</code> возвращает <code>false</code>. <code>!false</code> возвращает <code>true</code>.

</p>
</details>

<h1 id="12">12</h1>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">number</span>++);
<span class="hljs-built_in">console</span>.log(++<span class="hljs-built_in">number</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">number</span>);
</code></pre>
<ul>
<li>A: <code>1</code> <code>1</code> <code>2</code></li>
<li>B: <code>1</code> <code>2</code> <code>2</code></li>
<li>C: <code>0</code> <code>2</code> <code>2</code></li>
<li>D: <code>0</code> <code>1</code> <code>2</code></li>
</ul>
<details><summary><b>Ответ</b></summary>
<p>

#### Ответ: C

<strong>Постфиксный</strong> унарный оператор <code>++</code>:

1. Возвращает значение (<code>0</code>)
2. Инкрементирует значение (теперь число равно <code>1</code>)

<strong>Префиксный</strong> унарный оператор <code>++</code>:

1. Инкрементирует значение (число теперь равно <code>2</code>)
2. Возвращает значение (<code>2</code>)

Результат: <code>0 2 2</code>.

</p>
</details>

<h1 id="13">13</h1>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkAge</span>(<span class="hljs-params">data</span>) </span>{
  <span class="hljs-keyword">if</span> (data === { <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> }) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Ты взрослый!"</span>);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data == { <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> }) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Ты все еще взрослый."</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Хмм.. Кажется, у тебя нет возраста.`</span>);
  }
}

checkAge({ <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> });
</code></pre>
<ul>
<li>A: <code>Ты взрослый!</code></li>
<li>B: <code>Ты все еще взрослый.</code></li>
<li>C: <code>Хмм.. Кажется, у тебя нет возраста.</code></li>
</ul>
<details><summary><b>Ответ</b></summary>
<p>

#### Ответ: C

В операциях сравнения примитивы сравниваются по их <em>значениям</em>, а объекты по <em>ссылкам</em>. JavaScript проверяет, чтобы объекты указывали на одну и ту же область памяти.

Сравниваемые объекты в нашем примере не такие: объект, переданный в качестве параметра, указывает на другую область памяти, чем объекты, используемые в сравнениях.

Поэтому <code>{ age: 18 } === { age: 18 }</code> и <code>{ age: 18 } == { age: 18 }</code> возвращают <code>false</code>.

</p>
</details>

<h1 id="14">14</h1>
<pre><code class="lang-javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">5</span>; i++) {
  <span class="hljs-keyword">if</span> (i === <span class="hljs-number">3</span>) <span class="hljs-keyword">continue</span>;
  console.<span class="hljs-built_in">log</span>(i);
}
</code></pre>
<ul>
<li>A: <code>1</code> <code>2</code></li>
<li>B: <code>1</code> <code>2</code> <code>3</code></li>
<li>C: <code>1</code> <code>2</code> <code>4</code></li>
<li>D: <code>1</code> <code>3</code> <code>4</code></li>
</ul>
<details><summary><b>Ответ</b></summary>
<p>

#### Ответ: C

Оператор <code>continue</code> пропускает итерацию, если условие возвращает <code>true</code>.

</p>
</details>

<h1 id="15">15</h1>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bark</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Woof!"</span>);
}

bark.animal = <span class="hljs-string">"dog"</span>;
</code></pre>
<ul>
<li>A: Ничего, всё в порядке!</li>
<li>B: <code>SyntaxError</code>. Нельзя добавлять свойства функциям таким способом.</li>
<li>C: <code>undefined</code></li>
<li>D: <code>ReferenceError</code></li>
</ul>
<details><summary><b>Ответ</b></summary>
<p>

#### Ответ: A

В JavaScript это возможно, т.к. функции это объекты! (Всё есть объект кроме примитивов).

Функция — это специальный тип объекта, который можно вызвать. Кроме того, функция — это объект со свойствами. Свойство такого объекта нельзя вызвать, так как оно не является функцией.

</p>
</details>

<h1 id="16">16</h1>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> sum = <span class="hljs-built_in">eval</span>(<span class="hljs-string">"10*10+5"</span>)<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li>A: <code>105</code></li>
<li>B: <code>&quot;105&quot;</code></li>
<li>C: <code>TypeError</code></li>
<li>D: <code>&quot;10*10+5&quot;</code></li>
</ul>
<details><summary><b>Ответ</b></summary>
<p>

#### Ответ: A

<code>eval</code> выполняет код, переданный в виде строки. Если это выражение (как в данном случае), то вычисляется выражение. Выражение <code>10 * 10 + 5</code> вернет число <code>105</code>.

</p>
</details>

<h1 id="17">17</h1>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getInfo</span>(<span class="hljs-params">member, year</span>) </span>{
  member.name = <span class="hljs-string">"Lydia"</span>;
  year = <span class="hljs-number">1998</span>;
}

<span class="hljs-keyword">const</span> person = { <span class="hljs-attr">name</span>: <span class="hljs-string">"Sarah"</span> };
<span class="hljs-keyword">const</span> birthYear = <span class="hljs-string">"1997"</span>;

getInfo(person, birthYear);

<span class="hljs-built_in">console</span>.log(person, birthYear);
</code></pre>
<ul>
<li>A: <code>{ name: &quot;Lydia&quot; }, &quot;1997&quot;</code></li>
<li>B: <code>{ name: &quot;Sarah&quot; }, &quot;1998&quot;</code></li>
<li>C: <code>{ name: &quot;Lydia&quot; }, &quot;1998&quot;</code></li>
<li>D: <code>{ name: &quot;Sarah&quot; }, &quot;1997&quot;</code></li>
</ul>
<details><summary><b>Ответ</b></summary>
<p>

#### Ответ: A

Аргументы передаются <em>значением</em>, если их значение не является объектом, то они передаются <em>ссылкой</em>. <code>birthYear</code> передается по значению, поскольку это строка, а не объект. Когда мы передаем аргументы по значению, создается <em>копия</em> этого значения (см. вопрос 46).

Переменная <code>birthYear</code> имеет ссылку на значение <code>&quot;1997&quot;</code>. Аргумент <code>year</code> также имеет ссылку на значение<code>&quot;1997&quot;</code>, но это не то же самое значение, на которое имеется ссылка для <code>birthYear</code>. Когда мы обновляем значение <code>year</code>, устанавливая <code>year</code> равным <code>&quot;1998&quot;</code>, мы обновляем только значение <code>year</code>. <code>birthYear</code> по-прежнему равно <code>&quot;1997&quot;</code>.

Значение <code>person</code> является объектом. Аргумент <code>member</code> имеет (скопированную) ссылку на <em>тот же</em> объект. Когда мы изменяем свойство объекта, на который <code>member</code> ссылается, значение <code>person</code> также будет изменено, поскольку они оба имеют ссылку на один и тот же объект. Свойство <code>name</code> объекта <code>person</code> теперь равно значению <code>&quot;Lydia&quot;</code>.

</p>
</details>

<h1 id="18">18</h1>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-number">10</span>;

<span class="hljs-keyword">const</span> increaseNumber = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> num++;
<span class="hljs-keyword">const</span> increasePassedNumber = <span class="hljs-function"><span class="hljs-params">number</span> =&gt;</span> number++;

<span class="hljs-keyword">const</span> num1 = increaseNumber();
<span class="hljs-keyword">const</span> num2 = increasePassedNumber(num1);

<span class="hljs-built_in">console</span>.log(num1);
<span class="hljs-built_in">console</span>.log(num2);
</code></pre>
<ul>
<li>A: <code>10</code>, <code>10</code></li>
<li>B: <code>10</code>, <code>11</code></li>
<li>C: <code>11</code>, <code>11</code></li>
<li>D: <code>11</code>, <code>12</code></li>
</ul>
<details><summary><b>Ответ</b></summary>
<p>

#### Ответ: A

Унарный оператор <code>++</code> <em>сначала возвращает</em> значение операнда, <em>затем приращивает</em> значение операнда. Значение <code>num1</code> равно <code>10</code>, так как функция увеличений вначале возвращает значение <code>num</code>, которое равно <code>10</code>, и только затем увеличивает значение <code>num</code>.

<code>num2</code> - это <code>10</code>, так как мы передали <code>num1</code> в <code>incpasePassedNumber</code>. <code>number</code> равно <code>10</code> (значение <code>num1</code>. Опять же, унарный оператор <code>++</code> <em>сначала возвращает</em> значение операнда, <em>затем увеличивает</em> значение операнда. Значение <code>number</code> равно <code>10</code>, поэтому <code>num2</code> равно <code>10</code>.

</p>
</details>

<h1 id="19">19</h1>
<pre><code class="lang-javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-number">2</span>) === <span class="hljs-built_in">Number</span>(<span class="hljs-number">2</span>))
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">false</span>) === <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">false</span>))
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'foo'</span>) === <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'foo'</span>))
</code></pre>
<ul>
<li>A: <code>true</code>, <code>true</code>, <code>false</code></li>
<li>B: <code>false</code>, <code>true</code>, <code>false</code></li>
<li>C: <code>true</code>, <code>false</code>, <code>true</code></li>
<li>D: <code>true</code>, <code>true</code>, <code>true</code></li>
</ul>
<details><summary><b>Ответ</b></summary>
<p>

#### Ответ: A

Каждый <code>Symbol</code> совершенно уникален. Цель аргумента, переданного <code>Symbol</code>, состоит в том, чтобы дать <code>Symbol</code> описание. Значение <code>Symbol</code> не зависит от переданного аргумента. Когда мы проверяем равенство, мы создаем два совершенно новых <code>Symbol</code>: первый <code>Symbol(&#39;foo&#39;)</code> и второй <code>Symbol(&#39;foo&#39;)</code>. Эти два значения уникальны и не равны друг другу, <code>Symbol(&#39;foo&#39;) === Symbol(&#39;foo&#39;)</code> возвращает <code>false</code>.

</p>
</details>

<h1 id="20">20</h1>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> <span class="hljs-built_in">shape</span> = {
  radius: <span class="hljs-number">10</span>,
  diameter() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.radius * <span class="hljs-number">2</span>;
  },
  perimeter: () =&gt; <span class="hljs-number">2</span> * Math.<span class="hljs-literal">PI</span> * <span class="hljs-keyword">this</span>.radius
};

<span class="hljs-built_in">shape</span>.diameter();
<span class="hljs-built_in">shape</span>.perimeter();
</code></pre>
<ul>
<li>A: <code>20</code> и <code>62.83185307179586</code></li>
<li>B: <code>20</code> и <code>NaN</code></li>
<li>C: <code>20</code> и <code>63</code></li>
<li>D: <code>NaN</code> и <code>63</code></li>
</ul>
<details><summary><b>Ответ</b></summary>
<p>

#### Ответ: B

Заметь, что <code>diameter</code> это обычная функция, в то время как <code>perimeter</code> это стрелочная функция.

У стрелочных функций значение <code>this</code> указывает на окружающую область видимости, в отличие от обычных функций! Это значит, что при вызове <code>perimeter</code> значение <code>this</code> у этой функции указывает не на объект <code>shape</code>, а на внешнюю область видимости (например, window).

У этого объекта нет ключа <code>radius</code>, поэтому возвращается <code>undefined</code>.

</p>
</details>

<h1 id="21">21</h1>
<pre><code class="lang-javascript">let c = { greeting: <span class="hljs-string">"Hey!"</span> }<span class="hljs-comment">;</span>
let d<span class="hljs-comment">;</span>

d = c<span class="hljs-comment">;</span>
c.greeting = <span class="hljs-string">"Hello"</span><span class="hljs-comment">;</span>
console.log(d.greeting)<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li>A: <code>Hello</code></li>
<li>B: <code>Hey!</code></li>
<li>C: <code>undefined</code></li>
<li>D: <code>ReferenceError</code></li>
<li>E: <code>TypeError</code></li>
</ul>
<details><summary><b>Ответ</b></summary>
<p>

#### Ответ: A

В JavaScript все объекты являются <em>ссылочными</em> типами данных.

Сперва переменная <code>c</code> указывает на объект. Затем мы указываем переменной <code>d</code> ссылаться на тот же объект, что и <code>c</code>.

<img src="https://i.imgur.com/ko5k0fs.png" width="200">

Когда ты изменяешь один объект, то изменяются значения всех ссылок, указывающих на этот объект.

</p>
</details>

<h1 id="22">22</h1>
<pre><code class="lang-javascript">let greeting<span class="hljs-comment">;</span>
<span class="hljs-attribute">greetign</span> = {}<span class="hljs-comment">; // Опечатка!</span>
console.log(greetign)<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li>A: <code>{}</code></li>
<li>B: <code>ReferenceError: greetign is not defined</code></li>
<li>C: <code>undefined</code></li>
</ul>
<details><summary><b>Ответ</b></summary>
<p>

#### Ответ: A

В консоли выведется объект, потому что мы только что создали пустой объект в глобальном объекте! Когда мы вместо <code>greeting</code> написали <code>greetign</code>, интерпретатор JS на самом деле выполнил <code>global.greetign = {}</code> (или <code>window.greetign = {}</code> в браузере).

Нужно использовать <code>&quot;use strict&quot;</code>, чтобы избежать такого поведения. Эта запись поможет быть уверенным в том, что переменная была определена перед тем как ей присвоили значение.

</p>
</details>

<h1 id="23">23</h1>
<pre><code class="lang-javascript">const a = {}<span class="hljs-comment">;</span>
const <span class="hljs-keyword">b </span>= { key: <span class="hljs-string">"b"</span> }<span class="hljs-comment">;</span>
const c = { key: <span class="hljs-string">"c"</span> }<span class="hljs-comment">;</span>

a[<span class="hljs-keyword">b] </span>= <span class="hljs-number">123</span><span class="hljs-comment">;</span>
a[c] = <span class="hljs-number">456</span><span class="hljs-comment">;</span>

console.log(a[<span class="hljs-keyword">b]);</span>
</code></pre>
<ul>
<li>A: <code>123</code></li>
<li>B: <code>456</code></li>
<li>C: <code>undefined</code></li>
<li>D: <code>ReferenceError</code></li>
</ul>
<details><summary><b>Ответ</b></summary>
<p>

#### Ответ: B

Ключи объекта автоматически конвертируются в строки. Мы собираемся добавить объект в качестве ключа к объекту <code>a</code> со значением <code>123</code>.

Тем не менее, когда мы приводим объект к строке, он становится <code>&quot;[object Object]&quot;</code>. Таким образом, мы говорим, что <code>a[&quot;object Object&quot;] = 123</code>. Потом мы делаем то же самое. <code>c</code> это другой объект, который мы неявно приводим к строке. Поэтому <code>a[&quot;object Object&quot;] = 456</code>.

Затем, когда мы выводим <code>a[b]</code>, мы имеем в виду <code>a[&quot;object Object&quot;]</code>. Мы только что установили туда значение <code>456</code>, поэтому в результате получаем <code>456</code>.

</p>
</details>

<h1 id="24">24</h1>
<pre><code class="lang-javascript">const obj = { <span class="hljs-string">a:</span> <span class="hljs-string">"one"</span>, <span class="hljs-string">b:</span> <span class="hljs-string">"two"</span>, <span class="hljs-string">a:</span> <span class="hljs-string">"three"</span> };
console.log(obj);
</code></pre>
<ul>
<li>A: <code>{ a: &quot;one&quot;, b: &quot;two&quot; }</code></li>
<li>B: <code>{ b: &quot;two&quot;, a: &quot;three&quot; }</code></li>
<li>C: <code>{ a: &quot;three&quot;, b: &quot;two&quot; }</code></li>
<li>D: <code>SyntaxError</code></li>
</ul>
<details><summary><b>Ответ</b></summary>
<p>

#### Ответ: C

Если есть два ключа с одинаковым именем, то ключ будет перезаписан. Его позиция сохранится, но значением будет последнее указанное.

</p>
</details>

<h1 id="25">25</h1>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> <span class="hljs-attr">person</span> = { name: <span class="hljs-string">"Lydia"</span> };
const <span class="hljs-attr">members</span> = [person];
<span class="hljs-attr">person</span> = <span class="hljs-literal">null</span>;

console.log(members);
</code></pre>
<ul>
<li>A: <code>null</code></li>
<li>B: <code>[null]</code></li>
<li>C: <code>[{}]</code></li>
<li>D: <code>[{ name: &quot;Lydia&quot; }]</code></li>
</ul>
<details><summary><b>Ответ</b></summary>
<p>

#### Ответ: D

Сначала мы объявляем переменную <code>person</code> со значением объекта, у которого есть свойство<code>name</code>.

<img src="https://i.imgur.com/TML1MbS.png" width="200">

Затем мы объявляем переменную с именем <code>members</code>. Мы устанавливаем первый элемент этого массива равным значению переменной <code>person</code>. Объекты взаимодействуют посредством <em>ссылок</em> при установке их равными друг другу. Когда вы назначаете ссылку из одной переменной в другую, вы создаете <em>копию</em> этой ссылки. (обратите внимание, что у них <em>не одинаковые</em> ссылки!)

<img src="https://i.imgur.com/FSG5K3F.png" width="300">

Затем мы присваиваем переменной <code>person</code> значение <code>null</code>.

<img src="https://i.imgur.com/sYjcsMT.png" width="300">

Мы изменили только значение переменной <code>person</code>, а не первый элемент в массиве, поскольку этот элемент имеет другую (скопированную) ссылку на объект. Первый элемент в <code>members</code> по-прежнему содержит ссылку на исходный объект. Когда мы выводим в консоль массив <code>members</code>, первый элемент по-прежнему содержит значение объекта, который выводится в консоль.

</p>
</details>

<h1 id="26">26</h1>
<pre><code class="lang-javascript">function addToList(<span class="hljs-built_in">item</span>, <span class="hljs-built_in">list</span>) {
<span class="hljs-built_in">  return</span> <span class="hljs-built_in">list</span>.push(<span class="hljs-built_in">item</span>);
}

const <span class="hljs-literal">result</span> = addToList(<span class="hljs-string">"apple"</span>, [<span class="hljs-string">"banana"</span>]);
console.<span class="hljs-built_in">log</span>(<span class="hljs-literal">result</span>);
</code></pre>
<ul>
<li>A: <code>[&#39;apple&#39;, &#39;banana&#39;]</code></li>
<li>B: <code>2</code></li>
<li>C: <code>true</code></li>
<li>D: <code>undefined</code></li>
</ul>
<details><summary><b>Ответ</b></summary>
<p>

#### Ответ: B

Метод <code>.push()</code> возвращает <em>длину</em> нового массива! Ранее массив содержал один элемент (строка <code>&quot;banana&quot;</code>) и имел длину <code>1</code>. После добавления в массив строки <code>&quot;apple&quot;</code>, массив содержит два элемента и имеет длину <code>2</code>. Это возвращается из функции <code>addToList</code>.

Метод <code>push</code> изменяет исходный массив. Если вы хотите вернуть <em>массив</em> из функции, а не <em>длину массива</em>, вы должны были вернуть <code>list</code> после добавления в нее <code>item</code>.

</p>
</details>

<h1 id="27">27</h1>
<pre><code class="lang-javascript">const myLifeSummedUp = [<span class="hljs-string">"☕"</span>, <span class="hljs-string">"💻"</span>, <span class="hljs-string">"🍷"</span>, <span class="hljs-string">"🍫"</span>]

<span class="hljs-keyword">for</span> (let <span class="hljs-built_in">item</span> <span class="hljs-keyword">in</span> myLifeSummedUp) {
  console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">item</span>)
}

<span class="hljs-keyword">for</span> (let <span class="hljs-built_in">item</span> <span class="hljs-keyword">of</span> myLifeSummedUp) {
  console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">item</span>)
}
</code></pre>
<ul>
<li>A: <code>0</code> <code>1</code> <code>2</code> <code>3</code> и <code>&quot;☕&quot;</code> <code>&quot;💻&quot;</code> <code>&quot;🍷&quot;</code> <code>&quot;🍫&quot;</code></li>
<li>B: <code>&quot;☕&quot;</code> <code>&quot;💻&quot;</code> <code>&quot;🍷&quot;</code> <code>&quot;🍫&quot;</code> и <code>&quot;☕&quot;</code> <code>&quot;💻&quot;</code> <code>&quot;🍷&quot;</code> <code>&quot;🍫&quot;</code></li>
<li>C: <code>&quot;☕&quot;</code> <code>&quot;💻&quot;</code> <code>&quot;🍷&quot;</code> <code>&quot;🍫&quot;</code> и <code>0</code> <code>1</code> <code>2</code> <code>3</code></li>
<li>D:  <code>0</code> <code>1</code> <code>2</code> <code>3</code> и <code>{0: &quot;☕&quot;, 1: &quot;💻&quot;, 2: &quot;🍷&quot;, 3: &quot;🍫&quot;}</code></li>
</ul>
<details><summary><b>Ответ</b></summary>
<p>

#### Ответ: A

С помощью цикла <em>for-in</em> мы можем перебирать <strong>перечисляемые</strong> свойства. В массиве перечисляемые свойства являются &quot;ключами&quot; элементов массива, которые фактически являются их индексами. Вы можете увидеть массив как:

<code>{0: &quot;☕&quot;, 1: &quot;💻&quot;, 2: &quot;🍷&quot;, 3: &quot;🍫&quot;}</code>

Где ключи - перечисляемые свойства. <code>0</code> <code>1</code> <code>2</code> <code>3</code> войти в систему.

С помощью цикла <em>for-of</em> мы можем выполнять итерацию <strong>итераций</strong>. Массив является итеративным. Когда мы выполняем итерацию по массиву, переменная &quot;item&quot; равна элементу, по которому она итерируется в данный момент, <code>&quot;☕&quot;</code> <code>&quot;💻&quot;</code> <code>&quot;🍷&quot;</code> <code>&quot;🍫&quot;</code> выводится в лог.

</p>
</details>

<h1 id="28">28</h1>
<pre><code class="lang-javascript">const numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
numbers[<span class="hljs-number">10</span>] = <span class="hljs-number">11</span>;
console.log(numbers);
</code></pre>
<ul>
<li>A: <code>[1, 2, 3, 7 x null, 11]</code></li>
<li>B: <code>[1, 2, 3, 11]</code></li>
<li>C: <code>[1, 2, 3, 7 x empty, 11]</code></li>
<li>D: <code>SyntaxError</code></li>
</ul>
<details><summary><b>Ответ</b></summary>
<p>

#### Ответ: C

Когда в массив добавляется значение, которое выходит за пределы длины массива, JavaScript создает так называемые &quot;пустые ячейки&quot;. На самом деле они имеют значения <code>undefined</code>, но в консоли выводятся так:

<code>[1, 2, 3, 7 x empty, 11]</code>

в зависимости от окружения (может отличаться для браузеров, Node, и т.д.).

</p>
</details>

<h1 id="29">29</h1>
<pre><code class="lang-javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].map(<span class="hljs-built_in">num</span> =&gt; {
  <span class="hljs-keyword">if</span> (typeof <span class="hljs-built_in">num</span> === <span class="hljs-string">"number"</span>) <span class="hljs-keyword">return</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">num</span> * <span class="hljs-number">2</span>;
});
</code></pre>
<ul>
<li>A: <code>[]</code></li>
<li>B: <code>[null, null, null]</code></li>
<li>C: <code>[undefined, undefined, undefined]</code></li>
<li>D: <code>[ 3 x empty ]</code></li>
</ul>
<details><summary><b>Ответ</b></summary>
<p>

#### Ответ: C

При использовании метода map, значение <code>num</code> равно элементу, над которым он в данный момент зацикливается. В этом случае элементы являются числами, поэтому условие оператора if <code>typeof num === &quot;number&quot;</code> возвращает <code>true</code>. Функция map создает новый массив и вставляет значения, возвращаемые функцией.

Однако мы не возвращаем значение. Когда мы не возвращаем значение из функции, функция возвращает значение <code>undefined</code>. Для каждого элемента в массиве вызывается функциональный блок, поэтому для каждого элемента мы возвращаем <code>undefined</code>.

</p>
</details>

<h1 id="30">30</h1>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">`Hi there, <span class="hljs-subst">${name}</span>`</span>
}

<span class="hljs-built_in">console</span>.log(sayHi())
</code></pre>
<ul>
<li>A: <code>Hello there,</code></li>
<li>B: <code>Hello there, undefined</code></li>
<li>C: <code>Hello there, null</code></li>
<li>D:  <code>ReferenceError</code></li>
</ul>
<details><summary><b>Ответ</b></summary>
<p>

#### Ответ: B

По умолчанию аргументы имеют значение <code>undefined</code>, если только значение не было передано функции. В этом случае мы не передали значение для аргумента <code>name</code>. <code>name</code> равно логгируемому <code>undefined</code>.

В ES6 мы можем перезаписать значение по умолчанию <code>undefined</code> параметрами по умолчанию. Например:

<code>function sayHi(name = &quot;Lydia&quot;) { ... }</code>

В этом случае, если мы не передали значение или если мы передали <code>undefined</code>, <code>name</code> всегда будет равно строке <code>Lydia</code>

</p>
</details>

<h1 id="31">31</h1>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkAge</span>(<span class="hljs-params">age</span>) </span>{
  <span class="hljs-keyword">if</span> (age &lt; <span class="hljs-number">18</span>) {
    <span class="hljs-keyword">const</span> message = <span class="hljs-string">"Sorry, you're too young."</span>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">const</span> message = <span class="hljs-string">"Yay! You're old enough!"</span>
  }

  <span class="hljs-keyword">return</span> message
}

<span class="hljs-built_in">console</span>.log(checkAge(<span class="hljs-number">21</span>))
</code></pre>
<ul>
<li>A: <code>&quot;Sorry, you&#39;re too young.&quot;</code></li>
<li>B: <code>&quot;Yay! You&#39;re old enough!&quot;</code></li>
<li>C: <code>ReferenceError</code></li>
<li>D: <code>undefined</code></li>
</ul>
<details><summary><b>Ответ</b></summary>
<p>

#### Ответ: C

Переменные с ключевыми словами <code>const</code> и <code>let</code> имеют <em>блочную видимость</em>. Блок - это что-то между фигурными скобками (<code>{}</code>). В этом случае в фигурных скобках операторов if/else. Вы не можете ссылаться на переменную за пределами блока, в котором она объявлена, вызывается ReferenceError.

</p>
</details>

<h1 id="32">32</h1>
<pre><code class="lang-javascript"><span class="hljs-built_in">console</span>.log(`<span class="javascript">${(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x)(<span class="hljs-string">'I love'</span>)} to program</span>`)
</code></pre>
<ul>
<li>A: <code>I love to program</code></li>
<li>B: <code>undefined to program</code></li>
<li>C: <code>${(x =&gt; x)(&#39;I love&#39;) to program</code></li>
<li>D: <code>TypeError</code></li>
</ul>
<details><summary><b>Ответ</b></summary>
<p>

#### Ответ: A

Выражения внутри литералов шаблона расчитываются первыми. Это означает, что строка будет содержать возвращаемое значение выражения, в данном случае немедленно исполняемую функцию <code>(x =&gt; x)(&#39;I love&#39;)</code>. Мы передаем значение <code>&#39;I love&#39;</code> в качестве аргумента стрелочной функции <code>x =&gt; x</code>. <code>x</code> равно <code>&#39;I love&#39;</code>, которое и возвращается. Это приводит к <code>I love to program</code>.

</p>
</details>